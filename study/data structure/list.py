# ==================================================
# 1. 리스트 생성 및 기본 접근
# ==================================================

a = []                  # 빈 리스트 생성
b = [1, 2, 3]           # 초기값을 가진 리스트
c = list(range(5))      # range 객체를 리스트로 변환 → [0, 1, 2, 3, 4]
d = [0] * 5             # 같은 값으로 초기화된 리스트 생성

first = b[0]            # 인덱스 0 → 첫 번째 요소
last = b[-1]            # 음수 인덱스 → 마지막 요소


# ==================================================
# 2. 슬라이싱 (부분 리스트 추출)
# ==================================================

arr = [1, 2, 3, 4, 5]

slice1 = arr[1:4]       # 인덱스 1 이상, 4 미만 → [2, 3, 4]
slice2 = arr[:3]        # 처음부터 3 미만 → [1, 2, 3]
slice3 = arr[3:]        # 인덱스 3부터 끝 → [4, 5]
reverse_arr = arr[::-1] # step을 -1로 지정 → 리스트 역순
reverse_slice = arr[3:0:-1] # 인덱스 3(포함)부터 0 직전(즉, 인덱스 1)까지 역순


# ==================================================
# 3. 요소 추가 / 삭제
# ==================================================

lst = [1, 2, 3]

lst.append(4)           # 맨 뒤에 요소 하나 추가 (O(1))
lst.extend([5, 6])      # 여러 요소를 한 번에 추가
lst.insert(1, 10)       # 특정 위치에 삽입 (O(n), 느림)

lst.pop()               # 맨 뒤 요소 제거 후 반환
lst.pop(1)              # 특정 인덱스 요소 제거
lst.remove(2)           # 값으로 제거 (첫 번째만 제거)
del lst[0]               # 인덱스로 삭제


# ==================================================
# 4. 정렬
# ==================================================

nums = [3, 1, 4, 2]

nums.sort()             # 원본 리스트 자체를 오름차순 정렬
nums.sort(reverse=True) # 내림차순 정렬

nums2 = sorted(nums)    # 원본은 유지하고, 정렬된 새 리스트 반환
nums.sort(key=lambda x: x % 2)
# 정렬 기준을 직접 지정 (짝수/홀수 분리 등에서 자주 사용)


# ==================================================
# 5. 리스트 컴프리헨션 (가장 중요)
# ==================================================

squares = [x * x for x in range(5)]
# for문 + append를 한 줄로 표현 → 성능과 가독성 모두 좋음

evens = [x for x in range(10) if x % 2 == 0]
# 조건 필터링 포함

pairs = [(i, j) for i in range(3) for j in range(2)]
# 중첩 반복문을 한 줄로 표현


# ==================================================
# 6. 검색 및 집계
# ==================================================

data = [1, 2, 2, 3, 4]

has_two = 2 in data      # 특정 값 존재 여부 확인
count_two = data.count(2) # 특정 값 개수
index_three = data.index(3) # 특정 값의 첫 인덱스

length = len(data)       # 리스트 길이
total = sum(data)        # 합계
maximum = max(data)      # 최댓값
minimum = min(data)      # 최솟값


# ==================================================
# 7. 리스트 복사 (매우 중요, 실수 잦음)
# ==================================================

origin = [1, 2, 3]

ref = origin              # 같은 객체를 가리킴 (복사 아님)
copy1 = origin.copy()     # 얕은 복사
copy2 = origin[:]         # 얕은 복사 (슬라이싱 활용)

import copy
deep = copy.deepcopy(origin)
# 중첩 리스트까지 완전히 분리된 복사 (2차원 이상에서 중요)


# ==================================================
# 8. 2차원 리스트 (중첩 리스트)
# ==================================================

matrix = [[0] * 3 for _ in range(4)]
# 각 행이 서로 다른 객체 → 올바른 초기화

# bad_matrix = [[0] * 3] * 4
# 모든 행이 같은 객체를 참조 → 사용하면 버그 발생


# ==================================================
# 9. 스택 / 큐 패턴
# ==================================================

# 스택 (LIFO: 후입선출)
stack = []
stack.append(1)          # push
stack.append(2)
stack.pop()              # pop

# 큐 (FIFO: 선입선출) → 리스트 대신 deque 사용 권장
from collections import deque

queue = deque()
queue.append(1)          # enqueue
queue.append(2)
queue.popleft()          # dequeue (O(1))


# ==================================================
# 10. 변환 (map, filter)
# ==================================================

str_nums = ['1', '2', '3']
int_nums = list(map(int, str_nums))
# 문자열 리스트 → 정수 리스트 변환

filtered = list(filter(lambda x: x > 2, [1, 2, 3, 4]))
# 조건에 맞는 요소만 필터링
